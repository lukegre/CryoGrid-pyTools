<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>API Reference - CryoGrid-pyTools</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../stylesheets/extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "API Reference";
        var mkdocs_page_input_path = "api-reference.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> CryoGrid-pyTools
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../installation/">Installation</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Usage</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../usage/getting-started/">Getting Started</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../usage/reading-output/">Reading CryoGrid Output</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../usage/reading-matlab/">Reading MATLAB Structs</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../usage/forcing/">Working with Forcing Data</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../usage/spatial-data/">Spatial Data and Forcing</a>
                  </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">API Reference</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#main-functions">Main Functions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.read_OUT_regridded_FCI2_file">read_OUT_regridded_FCI2_file</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.read_OUT_regridded_FCI2_file--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.read_OUT_regridded_FCI2_file--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.read_OUT_regridded_FCI2_clusters">read_OUT_regridded_FCI2_clusters</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.read_OUT_regridded_FCI2_clusters--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.read_OUT_regridded_FCI2_clusters--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.matlab_helpers.read_mat_struct_flat_as_dict">read_mat_struct_flat_as_dict</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.matlab_helpers.read_mat_struct_flat_as_dict--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.matlab_helpers.read_mat_struct_flat_as_dict--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#forcing-functions">Forcing Functions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.forcing.read_mat_ear5">read_mat_ear5</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.forcing.read_mat_ear5--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.forcing.read_mat_ear5--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.forcing.era5_to_matlab">era5_to_matlab</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.forcing.era5_to_matlab--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.forcing.era5_to_matlab--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#configuration-functions">Configuration Functions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel">CryoGridConfigExcel</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.__init__">__init__</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.__init__--parameters">Parameters</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.check_files_exist">check_files_exist</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.check_forcing_fname_times">check_forcing_fname_times</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.check_forcing_fname_times--raises">Raises</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.check_strat_layers">check_strat_layers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class">get_class</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class_filepath">get_class_filepath</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class_filepath--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class_filepath--returns">Returns</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class_filepath--raises">Raises</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_classes">get_classes</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_classes--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_coord_path">get_coord_path</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_coord_path--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_dataset_paths">get_dataset_paths</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_dataset_paths--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_dem_path">get_dem_path</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_dem_path--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_forcing_path">get_forcing_path</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_forcing_path--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_forcing_path--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_output_max_depth">get_output_max_depth</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_output_max_depth--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_output_max_depth--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_start_end_times">get_start_end_times</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.CryoGridConfigExcel.get_start_end_times--returns">Returns</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.excel_config.check_strat_layer_values">check_strat_layer_values</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.check_strat_layer_values--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.check_strat_layer_values--raises">Raises</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.excel_config.check_strat_layer_values--notes">Notes</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.check_strat_layer_values--definitions">Definitions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cryogrid_pytools.excel_config.check_strat_layer_values--checks">Checks</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#data-module-functions">Data Module Functions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.data.get_dem_copernicus30">get_dem_copernicus30</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.data.get_dem_copernicus30--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.data.get_dem_copernicus30--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.data.get_esa_land_cover">get_esa_land_cover</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.data.get_esa_land_cover--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.data.get_esa_land_cover--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.data.get_snow_melt_doy">get_snow_melt_doy</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.data.get_snow_melt_doy--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.data.get_snow_melt_doy--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cryogrid_pytools.data.get_randolph_glacier_inventory">get_randolph_glacier_inventory</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.data.get_randolph_glacier_inventory--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cryogrid_pytools.data.get_randolph_glacier_inventory--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#utility-functions">Utility Functions</a>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">CryoGrid-pyTools</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">API Reference</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/lukegre/CryoGrid-pyTools/edit/master/docs/api-reference.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="api-reference">API Reference</h1>
<p>This page contains the detailed API reference for CryoGrid-pyTools.</p>
<h2 id="main-functions">Main Functions</h2>


<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.read_OUT_regridded_FCI2_file" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.read_OUT_regridded_FCI2_file(fname, deepest_point=None)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Read a CryoGrid OUT_regridded_FCI2 file and return it as an xarray dataset.</p>
<h4 id="cryogrid_pytools.read_OUT_regridded_FCI2_file--parameters">Parameters</h4>
<p>fname : str
    Path to the .mat file
deepest_point : float, optional
    Represents the deepest depth of the profile. If not provided, 
    then elevation is returned. Negative values represent depths below
    the surface.</p>
<h4 id="cryogrid_pytools.read_OUT_regridded_FCI2_file--returns">Returns</h4>
<p>ds : xarray.Dataset
    Dataset with dimensions 'time' and 'level'. The CryoGrid variable
    <code>depths</code> is renamed to <code>elevation</code>. If deepest_point is provided, then
    <code>depth</code> will represent the depth below the surface (negative below
    surface).</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/outputs.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_OUT_regridded_FCI2_file(fname:str, deepest_point=None)-&gt;xr.Dataset:
    """
    Read a CryoGrid OUT_regridded_FCI2 file and return it as an xarray dataset.

    Parameters
    ----------
    fname : str
        Path to the .mat file
    deepest_point : float, optional
        Represents the deepest depth of the profile. If not provided, 
        then elevation is returned. Negative values represent depths below
        the surface.

    Returns
    -------
    ds : xarray.Dataset
        Dataset with dimensions 'time' and 'level'. The CryoGrid variable
        `depths` is renamed to `elevation`. If deepest_point is provided, then
        `depth` will represent the depth below the surface (negative below
        surface).
    """
    from .matlab_helpers import read_mat_struct_flat_as_dict, matlab2datetime

    dat = read_mat_struct_flat_as_dict(fname)
    for key in dat:
        dat[key] = dat[key].squeeze()

    ds = xr.Dataset()
    ds.attrs['filename'] = fname

    times = matlab2datetime(dat.pop('timestamp'))
    elevation = dat.pop('depths')

    for key in dat:
        ds[key] = xr.DataArray(
            data = dat[key].astype('float32'), 
            dims=['level', 'time'], 
            coords={'time': times})

    ds['elevation'] = xr.DataArray(elevation, dims=['level'])

    if deepest_point is not None:
        assert deepest_point &lt; 0, "deepest_point must be negative (below surface)"

        ds = ds.rename(level='depth')

        # calculate depth step size
        n = elevation.size - 1
        s = (elevation[-1] - elevation[0]) / n

        significant_number = np.abs(np.floor(np.log10((np.abs(s))))).astype(int)
        # calculate shallowest point based on step size and n
        shallowest_point = deepest_point - (s * n)
        deepest_point += s / 2  # adding half step for arange
        depth = np.arange(shallowest_point, deepest_point, s, dtype='float32').round(significant_number)
        ds['depth'] = xr.DataArray(depth, dims=['depth'])
        ds = ds.set_coords('depth')
        ds = ds.transpose('depth', 'time', ...)
    else:  
        ds = ds.transpose('elevation', 'time', ...)

    ds = ds.chunk(dict(time=-1))

    return ds</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.read_OUT_regridded_FCI2_clusters" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.read_OUT_regridded_FCI2_clusters(fname_glob, deepest_point, **joblib_kwargs)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Reads multiple files that are put out by the OUT_regridded_FCI2 class</p>
<h4 id="cryogrid_pytools.read_OUT_regridded_FCI2_clusters--parameters">Parameters</h4>
<p>fname_glob: str
    Path of the files that you want to read in. 
    Use same notation as for glob(). Note that it expects
    name to follow the format <code>some_project_name_GRIDCELL_date.mat</code>
    where GRIDCELL will be extracted to assign the gridcell dimension. 
    These GRIDCELLs correspond with the index of the data in the 
    flattened array. 
deepest_point: float
    When setting the configuration for when the data should be 
    saved, the maximum depth is set. Give this number as a
    negative number here.
joblib_kwargs: dict
    Uses the joblib library to do parallel reading of the files. 
    Defaults are: n_jobs=-1, backend='threading', verbose=1</p>
<h4 id="cryogrid_pytools.read_OUT_regridded_FCI2_clusters--returns">Returns</h4>
<p>xr.Dataset
    An array with dimensions gridcell, depth, time. 
    Variables depend on how the class was configured, but
    elevation will also be a variable.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/outputs.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_OUT_regridded_FCI2_clusters(fname_glob:str, deepest_point:float, **joblib_kwargs)-&gt;xr.Dataset:
    """
    Reads multiple files that are put out by the OUT_regridded_FCI2 class

    Parameters
    ----------
    fname_glob: str
        Path of the files that you want to read in. 
        Use same notation as for glob(). Note that it expects
        name to follow the format `some_project_name_GRIDCELL_date.mat`
        where GRIDCELL will be extracted to assign the gridcell dimension. 
        These GRIDCELLs correspond with the index of the data in the 
        flattened array. 
    deepest_point: float
        When setting the configuration for when the data should be 
        saved, the maximum depth is set. Give this number as a
        negative number here.
    joblib_kwargs: dict
        Uses the joblib library to do parallel reading of the files. 
        Defaults are: n_jobs=-1, backend='threading', verbose=1

    Returns
    -------
    xr.Dataset
        An array with dimensions gridcell, depth, time. 
        Variables depend on how the class was configured, but
        elevation will also be a variable. 
    """
    from glob import glob

    # get the file list
    flist = sorted(glob(fname_glob))
    # extract the gridcell from the file name
    gridcell = [int(f.split('_')[-2]) for f in flist]

    list_of_ds = _read_OUT_regridded_FCI2_parallel(fname_glob, deepest_point, **joblib_kwargs)

    # assign the gridcell dimension so that we can combine the data by coordinates and time 
    list_of_ds = [ds.expand_dims(gridcell=[c]) for ds, c in zip(list_of_ds, gridcell)]
    ds = xr.combine_by_coords(list_of_ds, combine_attrs='drop_conflicts')

    # transpose data so that plotting is quick and easy
    ds = ds.transpose('gridcell', 'depth', 'time', ...)

    return ds</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.matlab_helpers.read_mat_struct_flat_as_dict" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.matlab_helpers.read_mat_struct_flat_as_dict(fname, key=None)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Read a MATLAB struct from a .mat file and return it as a dictionary.</p>
<p>Assumes that the struct is flat, i.e. it does not contain any nested
structs.</p>
<h4 id="cryogrid_pytools.matlab_helpers.read_mat_struct_flat_as_dict--parameters">Parameters</h4>
<p>fname : str
    Path to the .mat file
key : str, optional
    The name of the matlab key in the .mat file. If None is passed [default],
    then the first key that does not start with an underscore is used.
    If a string is passed, then the corresponding key is used.</p>
<h4 id="cryogrid_pytools.matlab_helpers.read_mat_struct_flat_as_dict--returns">Returns</h4>
<p>data : dict
    Dictionary with the struct fields as keys and the corresponding
    data as values.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/matlab_helpers.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_mat_struct_flat_as_dict(fname: str, key=None) -&gt; dict:
    """
    Read a MATLAB struct from a .mat file and return it as a dictionary.

    Assumes that the struct is flat, i.e. it does not contain any nested
    structs.

    Parameters
    ----------
    fname : str
        Path to the .mat file
    key : str, optional
        The name of the matlab key in the .mat file. If None is passed [default],
        then the first key that does not start with an underscore is used.
        If a string is passed, then the corresponding key is used.

    Returns
    -------
    data : dict
        Dictionary with the struct fields as keys and the corresponding
        data as values.
    """
    from scipy.io import loadmat

    raw = loadmat(fname)

    keys = [k for k in raw.keys() if not k.startswith('_')]

    if key is None:
        logger.log(5, f"No key specified. Using first key that does not start with an underscore: {keys[0]}")
        key = keys[0]
    elif key not in keys:
        raise ValueError(f"Key '{key}' not found in .mat file. Available keys are: {keys}")

    named_array = unnest_matlab_struct_named_array(raw[key])
    data = {k: named_array[k].squeeze() for k in named_array.dtype.names}

    return data</code></pre>
            </details>
    </div>

</div><h2 id="forcing-functions">Forcing Functions</h2>


<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.forcing.read_mat_ear5" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.forcing.read_mat_ear5(filename)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Read the ERA5.mat forcing file for CryoGrid and return a xarray Dataset.</p>
<h4 id="cryogrid_pytools.forcing.read_mat_ear5--parameters">Parameters</h4>
<p>filename : str
    Path to the ERA5.mat file</p>
<h4 id="cryogrid_pytools.forcing.read_mat_ear5--returns">Returns</h4>
<p>xr.Dataset
    Dataset with the variables from the ERA5.mat file</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/forcing.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_mat_ear5(filename: str) -&gt; xr.Dataset:
    """
    Read the ERA5.mat forcing file for CryoGrid and return a xarray Dataset.

    Parameters
    ----------
    filename : str
        Path to the ERA5.mat file

    Returns
    -------
    xr.Dataset
        Dataset with the variables from the ERA5.mat file
    """
    import pathlib
    from .matlab_helpers import read_mat_struct_flat_as_dict

    filename = pathlib.Path(filename).expanduser().absolute().resolve()

    dat = read_mat_struct_flat_as_dict(filename)
    out = _era5_mat_dict_to_xarray(dat)

    out = out.assign_attrs(
        info=(
            'Data read in from CryoGrid ERA5 forcing file. '
            'Data has been scaled to the original units with some modifications - units are given. '
            'Data has been transposed from [lon, lat, level, time] --&gt; [time, level, lat, lon]. '
            'See the ERA5 documentation for more info about the units etc.'),
        source=filename,
    )

    return out</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.forcing.era5_to_matlab" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.forcing.era5_to_matlab(ds, save_path=None)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Convert a merged netCDF file from the Copernicus CDS to 
a dictionary that matches the expected format of 
the CryoGrid.POST_PROC.read_mat_ERA class (in MATLAB).</p>
<h4 id="cryogrid_pytools.forcing.era5_to_matlab--parameters">Parameters</h4>
<p>ds : xr.Dataset
    Dataset from the ERA5 Copernicus CDS with variables required for 
    the CryoGrid.POST_PROC.read_mat_ERA class 
    single_levels   = [u10, v10, sp, d2m, t2m, ssrd, strd, tisr, tp, Zs]
    pressure_levels = [t, z, q, u, v]
    Note that Zs in the single levels is a special case since it is only 
    downloaded for a single date at the surface (doesn't change over time)
save_path : str, optional
    Path to save the dictionary as a .mat file, by default None, meaning 
    no file is saved and only the dictionary is returned</p>
<h4 id="cryogrid_pytools.forcing.era5_to_matlab--returns">Returns</h4>
<p>dict
    Dictionary with the variables mapped to names that are expected by 
    CryoGrid.POST_PROC.read_mat_ERA</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/forcing.py</code></summary>
              <pre class="highlight"><code class="language-python">def era5_to_matlab(ds: xr.Dataset, save_path: str = None) -&gt; dict:
    """
    Convert a merged netCDF file from the Copernicus CDS to 
    a dictionary that matches the expected format of 
    the CryoGrid.POST_PROC.read_mat_ERA class (in MATLAB).

    Parameters
    ----------
    ds : xr.Dataset
        Dataset from the ERA5 Copernicus CDS with variables required for 
        the CryoGrid.POST_PROC.read_mat_ERA class 
        single_levels   = [u10, v10, sp, d2m, t2m, ssrd, strd, tisr, tp, Zs]
        pressure_levels = [t, z, q, u, v]
        Note that Zs in the single levels is a special case since it is only 
        downloaded for a single date at the surface (doesn't change over time)
    save_path : str, optional
        Path to save the dictionary as a .mat file, by default None, meaning 
        no file is saved and only the dictionary is returned

    Returns
    -------
    dict
        Dictionary with the variables mapped to names that are expected by 
        CryoGrid.POST_PROC.read_mat_ERA
    """
    from .matlab_helpers import datetime2matlab
    import numpy as np

    # transpose to lon x lat x time (original is time x lat x lon)
    ds = ds.transpose('longitude', 'latitude', 'level', 'time')

    era = dict()
    era['dims'] = 'lon x lat (x pressure_levels) x time'
    # while lat and lon have to be [coord x 1]
    era['lat'] = ds['latitude'].values[:, None]
    era['lon'] = ds['longitude'].values[:, None]
    # pressure levels have to be [1 x coord] - only when pressure_levels present
    era['p'] = ds['level'].values[None] * 100 
    # time for some reason has to be [1 x coord]
    era['t'] = datetime2matlab(ds.time)[None] 
    # geopotential height at surface
    era['Zs'] = ds.Zs.values / 9.81  # gravity m/s2

    # single_level variables
    # wind and pressure (no transformations)
    era['u10'] = ds['u10'].values
    era['v10'] = ds['v10'].values
    era['ps'] = ds['sp'].values
    # temperature variables (degK -&gt; degC)
    era['Td2'] = ds['d2m'].values - 273.15
    era['T2'] = ds['t2m'].values - 273.15
    # radiation variables (/sec -&gt; /hour)
    era['SW'] = ds['ssrd'].values / 3600
    era['LW'] = ds['strd'].values / 3600
    era['S_TOA'] = ds['tisr'].values / 3600
    # precipitation (m -&gt; mm)
    era['P'] = ds['tp'].values * 1000

    # pressure levels
    era['T'] = ds['t'].values - 273.15  # K to C
    era['Z'] = ds['z'].values / 9.81  # gravity m/s2
    era['q'] = ds['q'].values
    era['u'] = ds['u'].values
    era['v'] = ds['v'].values

    # scaling factors
    era['wind_sf'] = 1e-2
    era['q_sf'] = 1e-6
    era['ps_sf'] = 1e2
    era['rad_sf'] = 1e-1
    era['T_sf'] = 1e-2
    era['P_sf'] = 1e-2

    # apply scaling factors (done in the original, so we do it here)
    # wind scaling
    era['u']     = (era['u']     / era['wind_sf']).astype(np.int16)
    era['v']     = (era['v']     / era['wind_sf']).astype(np.int16)
    era['u10']   = (era['u10']   / era['wind_sf']).astype(np.int16)
    era['v10']   = (era['v10']   / era['wind_sf']).astype(np.int16)
    # temperature scaling
    era['T']     = (era['T']     / era['T_sf']   ).astype(np.int16)
    era['Td2']   = (era['Td2']   / era['T_sf']   ).astype(np.int16)
    era['T2']    = (era['T2']    / era['T_sf']   ).astype(np.int16)
    # humidity scaling
    era['q']     = (era['q']     / era['q_sf']   ).astype(np.uint16)
    # pressure scaling
    era['ps']    = (era['ps']    / era['ps_sf']  ).astype(np.uint16)
    # radiation scaling
    era['SW']    = (era['SW']    / era['rad_sf'] ).astype(np.uint16)
    era['LW']    = (era['LW']    / era['rad_sf'] ).astype(np.uint16)
    era['S_TOA'] = (era['S_TOA'] / era['rad_sf'] ).astype(np.uint16)
    # precipitation scaling
    era['P']     = (era['P']     / era['P_sf']   ).astype(np.uint16)
    # no scaling for geoportential height
    era['Z']     = era['Z'].astype(np.int16)

    out = {'era': era}

    if save_path is not None and isinstance(save_path, str):
        from scipy.io import savemat
        savemat(save_path, out, appendmat=True, do_compression=True)

    return out</code></pre>
            </details>
    </div>

</div><h2 id="configuration-functions">Configuration Functions</h2>


<div class="doc doc-object doc-class">



<h2 id="cryogrid_pytools.excel_config.CryoGridConfigExcel" class="doc doc-heading">
            <code>cryogrid_pytools.excel_config.CryoGridConfigExcel</code>


</h2>


    <div class="doc doc-contents first">


        <p>A class to read CryoGrid Excel configuration files and extract file paths
and maybe in the future do some checks etc</p>







              <details class="quote">
                <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
                <pre class="highlight"><code class="language-python">class CryoGridConfigExcel:
    """
    A class to read CryoGrid Excel configuration files and extract file paths
    and maybe in the future do some checks etc
    """
    def __init__(self, fname_xls: str, check_file_paths=True, check_strat_layers=True):
        """
        Initialize the CryoGridConfigExcel object.

        Reads in the Excel configuration file and parse the different classes
        using a pandas DataFrame approach. 

        Parameters
        ----------
        fname_xls : path-like
            Path to the CryoGrid Excel configuration file.
        check_file_paths : bool, default=True, optional
            If True, perform a check that all files linked in the configuration 
            can be found (path exists)
        check_strat_layers : bool, default=True, optional
            If True, perform a check that stratigraphy layer parameters are 
            physically plausible
        """
        self.fname = pathlib.Path(fname_xls).resolve()
        self.root = self._get_root_path()
        self._df = self._load_xls(fname_xls)
        logger.success(f"Loaded CryoGrid Excel configuration file: {self.fname}")

        self.fname = Munch()
        self.fname.dem = self.get_dem_path()
        self.fname.coords = self.get_coord_path()
        self.fname.era5 = self.get_forcing_path()
        self.fname.datasets = self.get_dataset_paths()

        self.time = self.get_start_end_times()

        if check_file_paths:
            self.check_files_exist()
        if check_strat_layers:
            self.check_strat_layers()

        logger.info(f"Start and end times: {self.time.time_start:%Y-%m-%d} - {self.time.time_end:%Y-%m-%d}")

    def _get_root_path(self):
        """
        Find and set the root path by locating the 'run_cryogrid.m' file.

        Returns
        -------
        pathlib.Path
            The discovered root path or the current directory if not found.
        """
        path = self.fname.parent
        while True:
            flist = path.glob('run_cryogrid.m')
            if len(list(flist)) &gt; 0:
                self.root = path
                logger.info(f"Found root path: {path}")
                return self.root
            elif str(path) == '/':
                logger.warning("Could not find root path. Set to current directory. You can change this manually with excel_config.root = pathlib.Path('/path/to/root')")
                return pathlib.Path('.')
            else:
                path = path.parent

    def get_start_end_times(self):
        """
        Retrieve the start and end times from the Excel configuration.

        Returns
        -------
        pandas.Series
            A Series with 'time_start' and 'time_end' as Timestamp objects.
        """
        times = self.get_class('set_start_end_time').T.filter(regex='time')
        times = times.map(lambda x: pd.Timestamp(year=int(x[0]), month=int(x[1]), day=int(x[2])))

        start = times.start_time.min()
        end = times.end_time.max()
        times = pd.Series([start, end], index=['time_start', 'time_end'])

        return times

    def get_coord_path(self):
        """
        Get the path to the coordinates file from the Excel configuration.

        Returns
        -------
        pathlib.Path
            The file path for coordinates.
        """
        fname = self.get_class_filepath('COORDINATES_FROM_FILE', fname_key='file_name', index=1)
        return fname

    def get_dataset_paths(self):
        """
        Retrieve paths for each dataset from the Excel configuration.

        Returns
        -------
        munch.Munch
            A dictionary-like object mapping dataset variable names to file paths.
        """
        paths = self.get_class_filepath('READ_DATASET', fname_key='filename').to_frame(name='filepath').T

        datasets = self.get_class('READ_DATASET')
        variable = datasets.T.variable_name
        paths.loc['variable'] = variable

        paths = Munch(**paths.T.set_index('variable').filepath.to_dict())

        return paths

    def get_dem_path(self):
        """
        Get the path for the DEM file from the Excel configuration.

        Returns
        -------
        pathlib.Path
            The DEM file path.
        """
        fname = self.get_class_filepath('DEM', folder_key='folder', fname_key='filename', index=1)
        return fname

    def get_forcing_path(self, class_name='read_mat_ERA'):
        """
        Obtain the forcing file path from the Excel configuration.

        Parameters
        ----------
        class_name : str, optional
            The class name to search for in the configuration, by default 'read_mat_ERA'.

        Returns
        -------
        pathlib.Path
            The forcing file path.
        """
        fname = self.get_class_filepath(class_name, folder_key='path', fname_key='filename', index=1)
        return fname

    def get_output_max_depth(self, output_class="OUT_regridded_FCI2", depth_key='depth_below_ground')-&gt;int:
        """
        Get the maximum depth of the output file from the Excel configuration.

        Parameters
        ----------
        output_class : str, optional
            The class name to search for in the configuration, by default 'OUT_regridded_FCI2'.

        Returns
        -------
        float
            The maximum depth value.
        """
        df = self.get_class(output_class)

        depth = str(df.loc[depth_key].iloc[0])
        depth = int(depth)

        return depth

    def check_forcing_fname_times(self):
        """
        Check if the file name matches the forcing years specified in the Excel configuration.

        Raises
        ------
        AssertionError
            If the forcing years in the file name do not match those in the configuration.
        """
        import re

        fname = self.get_forcing_path()
        times = self.get_start_end_times().dt.year.astype(str).values.tolist()

        fname_years = re.findall(r'[-_]([12][1089][0-9][0-9])', fname.stem)

        assert times == fname_years, f"File name years do not match the forcing years: forcing {times} != fname {fname_years}"

    def _load_xls(self, fname_xls: str) -&gt; pd.DataFrame:
        """
        Load the Excel file into a DataFrame.

        Parameters
        ----------
        fname_xls : str
            Path to the Excel file.

        Returns
        -------
        pandas.DataFrame
            The loaded data with proper indexing and column names.
        """
        import string

        alph = list(string.ascii_uppercase)
        alphabet_extra = alph + [a+b for a in alph for b in alph]

        df = pd.read_excel(fname_xls, header=None, dtype=str)
        df.columns = [c for c in alphabet_extra[:df.columns.size]]
        df.index = df.index + 1

        return df

    def _get_unique_key(self, key: str, col_value='B'):
        """
        Retrieve a single unique value for a given key from the Excel data.

        Parameters
        ----------
        key : str
            The key to look for in column 'A'.
        col_value : str, optional
            The column to retrieve the value from, by default 'B'.

        Returns
        -------
        str or None
            The found value or None if no value exists.

        Raises
        ------
        ValueError
            If multiple values are found for the given key.
        """
        df  = self._df
        idx = df.A == key
        value = df.loc[idx, col_value].values
        if len(value) == 0:
            return None
        elif len(value) &gt; 1:
            raise ValueError(f"Multiple values found for key: {key}")
        else:
            return value[0]

    def get_classes(self):
        """
        Returns a dictionary of class names and their corresponding row indices
        from the Excel file. To use as a reference for get_class(&lt;class_name&gt;).

        Returns
        -------
        dict of int: str
            A dictionary mapping class names to row indices
        """
        df = self._df

        class_idx = []
        for i in range(len(df)):
            try: 
                self._find_class_block(i)
                class_idx.append(i)
            except:
                pass

        classes = df.loc[class_idx, 'A'].to_dict()
        return classes

    def get_class_filepath(self, key, folder_key='folder', fname_key='file', index=None):
        """
        Construct a file path from folder and file entries in the Excel configuration.

        Parameters
        ----------
        key : str
            The class name to search for.
        folder_key : str, optional
            Key to identify the folder in the DataFrame, by default 'folder'.
        fname_key : str, optional
            Key to identify the file name in the DataFrame, by default 'file'.
        index : int or None, optional
            If int, return a single entry. Otherwise return all matched entries.

        Returns
        -------
        pathlib.Path or pandas.Series
            The path(s) constructed from the Excel class entries.

        Raises
        ------
        AssertionError
            If multiple folder or filename keys are found.
        TypeError
            If index is not int or None.
        """
        df = self.get_class(key)

        keys = df.index.values
        folder_key = keys[[folder_key in k for k in keys]]
        fname_key = keys[[fname_key in k for k in keys]]

        assert len(folder_key) == 1, f"Multiple folder keys found: {folder_key}"
        assert len(fname_key) == 1, f"Multiple fname keys found: {fname_key}"

        names = df.loc[[folder_key[0], fname_key[0]]]
        names = names.apply(lambda ser: self.root / ser.iloc[0] / ser.iloc[1])

        if index is None:
            return names
        elif isinstance(index, int):
            return names.loc[f"{key}_{index}"]
        else:
            raise TypeError(f"index must be None or int, not {type(index)}")

    def get_class(self, class_name: str)-&gt;pd.DataFrame:
        """
        Return DataFrame blocks representing the specified class from the Excel data.

        Parameters
        ----------
        class_name : str
            The class name to look up (e.g., 'DEM', 'READ_DATASET').

        Returns
        -------
        pandas.DataFrame
            The concatenated DataFrame of class blocks.
        """
        df = self._df
        i0s = df.A == class_name
        i0s = i0s[i0s].index.values

        blocks = [self._find_class_block(i0) for i0 in i0s]
        try:
            df = pd.concat(blocks, axis=1)
        except:
            # only intended for debugging
            df = blocks  
            logger.warning(f"Could not concatenate blocks for class: {class_name}")

        return df

    def _find_class_block(self, class_idx0: int):
        """
        Identify and extract the block of rows corresponding to a class definition.

        Parameters
        ----------
        class_idx0 : int
            Starting row index for the class in the Excel data.

        Returns
        -------
        pandas.DataFrame
            The processed block as a DataFrame.

        Raises
        ------
        AssertionError
            If the class structure is missing required indicators.
        """
        df = self._df

        class_name = df.A.loc[class_idx0]
        msg = f"Given class_idx0 ({class_name}) is not a class. Must have 'index' adjacent or on cell up and right."
        is_index = df.B.loc[class_idx0 - 1: class_idx0].str.contains('index')
        assert is_index.any(), msg

        index_idx = is_index.idxmax()
        class_idx0 = index_idx

        class_idx1 = df.A.loc[class_idx0:] == 'CLASS_END'
        # get first True occurrence
        class_idx1 = class_idx1.idxmax()
        class_block = df.loc[class_idx0:class_idx1]
        class_block = self._process_class_block(class_block)

        return class_block

    def _process_class_block(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        """
        Process a raw class block by removing comments, handling special structures, and shaping data.

        Parameters
        ----------
        df : pandas.DataFrame
            A DataFrame slice representing the raw class block.

        Returns
        -------
        pandas.DataFrame
            The cleaned and structured DataFrame of class data.

        Raises
        ------
        AssertionError
            When matrix structures in the block do not match expected format.
        """
        """hacky way to process the class block"""
        # drop CLASS_END row
        df = df[df.A != 'CLASS_END']

        # if any cell starts with '&gt;', it is a comment
        df = df.map(lambda x: x if not str(x).startswith('&gt;') else np.nan)

        # drop rows and columns that are all NaN
        df = df.dropna(axis=1, how='all').dropna(axis=0, how='all')
        df = df.astype(str)

        # H_LIST and V_MATRIX are special cases
        contains_matrix = df.map(lambda x: 'MATRIX' in x).values
        contains_vmatrix = df.map(lambda x: 'V_MATRIX' in x).values
        contains_end = df.map(lambda x: 'END' in x).values

        ends = np.where(contains_end)
        if contains_matrix.any():
            r0, c0 = [a[0] for a in np.where(contains_matrix)]

            assert c0 == 1, "Matrix must be in second column"
            assert len(ends) == 2, "Only two ENDs are allowed"
            assert r0 == ends[0][0]
            assert c0 == ends[1][1]

            r1 = ends[0][1]
            c1 = ends[1][0]

            arr = df.iloc[r0:r1, c0:c1].values
            if contains_vmatrix.any():
                # first column of V_MATRIX is the index but is not in the config file
                # so we create it. It is one shorter than the num of rows because of header
                arr[1:, 0] = np.arange(r1 - r0 - 1)

            matrix = pd.DataFrame(arr[1:, 1:], index=arr[1:, 0], columns=arr[0, 1:])
            matrix.index.name = matrix.columns.name = df.iloc[r0, 0]
            df = df.drop(index=df.index[r0:r1+1])
            df.loc[r0, 'A'] = matrix.index.name
            df.loc[r0, 'B'] = matrix.to_dict(),

        for i, row in df.iterrows():
            # H_LIST first
            if row.str.contains('H_LIST').any():
                r0 = 2
                r1 = row.str.contains('END').argmax()
                df.loc[i, 'B'] = row.iloc[r0:r1].values.tolist()

        class_category = df.A.iloc[0]
        class_type = df.A.iloc[1]
        class_index = df.B.iloc[1]
        col_name = f'{class_type}_{class_index}'

        df = (
            df
            .iloc[2:, :2]
            .rename(columns=dict(B=col_name))
            .set_index('A'))
        df.index.name = class_category

        return df

    def check_strat_layers(self):
        """
        Run checks to ensure stratigraphy layers have physically plausible parameter values.
        """
        strat_layers = self.get_class('STRAT_layers')
        logger.info("Checking stratigraphy layers...")
        for layer in strat_layers:
            try:
                check_strat_layer_values(strat_layers[layer].iloc[0])
                logger.success(f"[{layer}]  parameters passed checks")
            except ValueError as error:
                logger.warning(f"[{layer}]  {error}")

    def check_files_exist(self):
        """
        Check if all the files in the configuration exist.
        """

        flist = set([
            self.get_forcing_path(), 
            self.get_dem_path(), 
            self.get_coord_path()] 
            + list(self.get_dataset_paths().values()))

        logger.info("Checking file locations...")
        for f in flist:
            if not f.exists():
                logger.warning(f"Cannot find file: {f}")
            else:
                logger.success(f"Located file: {f}")</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(fname_xls, check_file_paths=True, check_strat_layers=True)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize the CryoGridConfigExcel object.</p>
<p>Reads in the Excel configuration file and parse the different classes
using a pandas DataFrame approach. </p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.__init__--parameters">Parameters</h5>
<p>fname_xls : path-like
    Path to the CryoGrid Excel configuration file.
check_file_paths : bool, default=True, optional
    If True, perform a check that all files linked in the configuration 
    can be found (path exists)
check_strat_layers : bool, default=True, optional
    If True, perform a check that stratigraphy layer parameters are 
    physically plausible</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, fname_xls: str, check_file_paths=True, check_strat_layers=True):
    """
    Initialize the CryoGridConfigExcel object.

    Reads in the Excel configuration file and parse the different classes
    using a pandas DataFrame approach. 

    Parameters
    ----------
    fname_xls : path-like
        Path to the CryoGrid Excel configuration file.
    check_file_paths : bool, default=True, optional
        If True, perform a check that all files linked in the configuration 
        can be found (path exists)
    check_strat_layers : bool, default=True, optional
        If True, perform a check that stratigraphy layer parameters are 
        physically plausible
    """
    self.fname = pathlib.Path(fname_xls).resolve()
    self.root = self._get_root_path()
    self._df = self._load_xls(fname_xls)
    logger.success(f"Loaded CryoGrid Excel configuration file: {self.fname}")

    self.fname = Munch()
    self.fname.dem = self.get_dem_path()
    self.fname.coords = self.get_coord_path()
    self.fname.era5 = self.get_forcing_path()
    self.fname.datasets = self.get_dataset_paths()

    self.time = self.get_start_end_times()

    if check_file_paths:
        self.check_files_exist()
    if check_strat_layers:
        self.check_strat_layers()

    logger.info(f"Start and end times: {self.time.time_start:%Y-%m-%d} - {self.time.time_end:%Y-%m-%d}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.check_files_exist" class="doc doc-heading">
            <code class="highlight language-python">check_files_exist()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Check if all the files in the configuration exist.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def check_files_exist(self):
    """
    Check if all the files in the configuration exist.
    """

    flist = set([
        self.get_forcing_path(), 
        self.get_dem_path(), 
        self.get_coord_path()] 
        + list(self.get_dataset_paths().values()))

    logger.info("Checking file locations...")
    for f in flist:
        if not f.exists():
            logger.warning(f"Cannot find file: {f}")
        else:
            logger.success(f"Located file: {f}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.check_forcing_fname_times" class="doc doc-heading">
            <code class="highlight language-python">check_forcing_fname_times()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Check if the file name matches the forcing years specified in the Excel configuration.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.check_forcing_fname_times--raises">Raises</h5>
<p>AssertionError
    If the forcing years in the file name do not match those in the configuration.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def check_forcing_fname_times(self):
    """
    Check if the file name matches the forcing years specified in the Excel configuration.

    Raises
    ------
    AssertionError
        If the forcing years in the file name do not match those in the configuration.
    """
    import re

    fname = self.get_forcing_path()
    times = self.get_start_end_times().dt.year.astype(str).values.tolist()

    fname_years = re.findall(r'[-_]([12][1089][0-9][0-9])', fname.stem)

    assert times == fname_years, f"File name years do not match the forcing years: forcing {times} != fname {fname_years}"</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.check_strat_layers" class="doc doc-heading">
            <code class="highlight language-python">check_strat_layers()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Run checks to ensure stratigraphy layers have physically plausible parameter values.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def check_strat_layers(self):
    """
    Run checks to ensure stratigraphy layers have physically plausible parameter values.
    """
    strat_layers = self.get_class('STRAT_layers')
    logger.info("Checking stratigraphy layers...")
    for layer in strat_layers:
        try:
            check_strat_layer_values(strat_layers[layer].iloc[0])
            logger.success(f"[{layer}]  parameters passed checks")
        except ValueError as error:
            logger.warning(f"[{layer}]  {error}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class" class="doc doc-heading">
            <code class="highlight language-python">get_class(class_name)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return DataFrame blocks representing the specified class from the Excel data.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class--parameters">Parameters</h5>
<p>class_name : str
    The class name to look up (e.g., 'DEM', 'READ_DATASET').</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class--returns">Returns</h5>
<p>pandas.DataFrame
    The concatenated DataFrame of class blocks.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_class(self, class_name: str)-&gt;pd.DataFrame:
    """
    Return DataFrame blocks representing the specified class from the Excel data.

    Parameters
    ----------
    class_name : str
        The class name to look up (e.g., 'DEM', 'READ_DATASET').

    Returns
    -------
    pandas.DataFrame
        The concatenated DataFrame of class blocks.
    """
    df = self._df
    i0s = df.A == class_name
    i0s = i0s[i0s].index.values

    blocks = [self._find_class_block(i0) for i0 in i0s]
    try:
        df = pd.concat(blocks, axis=1)
    except:
        # only intended for debugging
        df = blocks  
        logger.warning(f"Could not concatenate blocks for class: {class_name}")

    return df</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class_filepath" class="doc doc-heading">
            <code class="highlight language-python">get_class_filepath(key, folder_key='folder', fname_key='file', index=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Construct a file path from folder and file entries in the Excel configuration.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class_filepath--parameters">Parameters</h5>
<p>key : str
    The class name to search for.
folder_key : str, optional
    Key to identify the folder in the DataFrame, by default 'folder'.
fname_key : str, optional
    Key to identify the file name in the DataFrame, by default 'file'.
index : int or None, optional
    If int, return a single entry. Otherwise return all matched entries.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class_filepath--returns">Returns</h5>
<p>pathlib.Path or pandas.Series
    The path(s) constructed from the Excel class entries.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_class_filepath--raises">Raises</h5>
<p>AssertionError
    If multiple folder or filename keys are found.
TypeError
    If index is not int or None.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_class_filepath(self, key, folder_key='folder', fname_key='file', index=None):
    """
    Construct a file path from folder and file entries in the Excel configuration.

    Parameters
    ----------
    key : str
        The class name to search for.
    folder_key : str, optional
        Key to identify the folder in the DataFrame, by default 'folder'.
    fname_key : str, optional
        Key to identify the file name in the DataFrame, by default 'file'.
    index : int or None, optional
        If int, return a single entry. Otherwise return all matched entries.

    Returns
    -------
    pathlib.Path or pandas.Series
        The path(s) constructed from the Excel class entries.

    Raises
    ------
    AssertionError
        If multiple folder or filename keys are found.
    TypeError
        If index is not int or None.
    """
    df = self.get_class(key)

    keys = df.index.values
    folder_key = keys[[folder_key in k for k in keys]]
    fname_key = keys[[fname_key in k for k in keys]]

    assert len(folder_key) == 1, f"Multiple folder keys found: {folder_key}"
    assert len(fname_key) == 1, f"Multiple fname keys found: {fname_key}"

    names = df.loc[[folder_key[0], fname_key[0]]]
    names = names.apply(lambda ser: self.root / ser.iloc[0] / ser.iloc[1])

    if index is None:
        return names
    elif isinstance(index, int):
        return names.loc[f"{key}_{index}"]
    else:
        raise TypeError(f"index must be None or int, not {type(index)}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_classes" class="doc doc-heading">
            <code class="highlight language-python">get_classes()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a dictionary of class names and their corresponding row indices
from the Excel file. To use as a reference for get_class(<class_name>).</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_classes--returns">Returns</h5>
<p>dict of int: str
    A dictionary mapping class names to row indices</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_classes(self):
    """
    Returns a dictionary of class names and their corresponding row indices
    from the Excel file. To use as a reference for get_class(&lt;class_name&gt;).

    Returns
    -------
    dict of int: str
        A dictionary mapping class names to row indices
    """
    df = self._df

    class_idx = []
    for i in range(len(df)):
        try: 
            self._find_class_block(i)
            class_idx.append(i)
        except:
            pass

    classes = df.loc[class_idx, 'A'].to_dict()
    return classes</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_coord_path" class="doc doc-heading">
            <code class="highlight language-python">get_coord_path()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the path to the coordinates file from the Excel configuration.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_coord_path--returns">Returns</h5>
<p>pathlib.Path
    The file path for coordinates.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_coord_path(self):
    """
    Get the path to the coordinates file from the Excel configuration.

    Returns
    -------
    pathlib.Path
        The file path for coordinates.
    """
    fname = self.get_class_filepath('COORDINATES_FROM_FILE', fname_key='file_name', index=1)
    return fname</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_dataset_paths" class="doc doc-heading">
            <code class="highlight language-python">get_dataset_paths()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Retrieve paths for each dataset from the Excel configuration.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_dataset_paths--returns">Returns</h5>
<p>munch.Munch
    A dictionary-like object mapping dataset variable names to file paths.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_dataset_paths(self):
    """
    Retrieve paths for each dataset from the Excel configuration.

    Returns
    -------
    munch.Munch
        A dictionary-like object mapping dataset variable names to file paths.
    """
    paths = self.get_class_filepath('READ_DATASET', fname_key='filename').to_frame(name='filepath').T

    datasets = self.get_class('READ_DATASET')
    variable = datasets.T.variable_name
    paths.loc['variable'] = variable

    paths = Munch(**paths.T.set_index('variable').filepath.to_dict())

    return paths</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_dem_path" class="doc doc-heading">
            <code class="highlight language-python">get_dem_path()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the path for the DEM file from the Excel configuration.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_dem_path--returns">Returns</h5>
<p>pathlib.Path
    The DEM file path.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_dem_path(self):
    """
    Get the path for the DEM file from the Excel configuration.

    Returns
    -------
    pathlib.Path
        The DEM file path.
    """
    fname = self.get_class_filepath('DEM', folder_key='folder', fname_key='filename', index=1)
    return fname</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_forcing_path" class="doc doc-heading">
            <code class="highlight language-python">get_forcing_path(class_name='read_mat_ERA')</code>

</h3>


    <div class="doc doc-contents ">

        <p>Obtain the forcing file path from the Excel configuration.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_forcing_path--parameters">Parameters</h5>
<p>class_name : str, optional
    The class name to search for in the configuration, by default 'read_mat_ERA'.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_forcing_path--returns">Returns</h5>
<p>pathlib.Path
    The forcing file path.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_forcing_path(self, class_name='read_mat_ERA'):
    """
    Obtain the forcing file path from the Excel configuration.

    Parameters
    ----------
    class_name : str, optional
        The class name to search for in the configuration, by default 'read_mat_ERA'.

    Returns
    -------
    pathlib.Path
        The forcing file path.
    """
    fname = self.get_class_filepath(class_name, folder_key='path', fname_key='filename', index=1)
    return fname</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_output_max_depth" class="doc doc-heading">
            <code class="highlight language-python">get_output_max_depth(output_class='OUT_regridded_FCI2', depth_key='depth_below_ground')</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the maximum depth of the output file from the Excel configuration.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_output_max_depth--parameters">Parameters</h5>
<p>output_class : str, optional
    The class name to search for in the configuration, by default 'OUT_regridded_FCI2'.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_output_max_depth--returns">Returns</h5>
<p>float
    The maximum depth value.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_output_max_depth(self, output_class="OUT_regridded_FCI2", depth_key='depth_below_ground')-&gt;int:
    """
    Get the maximum depth of the output file from the Excel configuration.

    Parameters
    ----------
    output_class : str, optional
        The class name to search for in the configuration, by default 'OUT_regridded_FCI2'.

    Returns
    -------
    float
        The maximum depth value.
    """
    df = self.get_class(output_class)

    depth = str(df.loc[depth_key].iloc[0])
    depth = int(depth)

    return depth</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_start_end_times" class="doc doc-heading">
            <code class="highlight language-python">get_start_end_times()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Retrieve the start and end times from the Excel configuration.</p>
<h5 id="cryogrid_pytools.excel_config.CryoGridConfigExcel.get_start_end_times--returns">Returns</h5>
<p>pandas.Series
    A Series with 'time_start' and 'time_end' as Timestamp objects.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_start_end_times(self):
    """
    Retrieve the start and end times from the Excel configuration.

    Returns
    -------
    pandas.Series
        A Series with 'time_start' and 'time_end' as Timestamp objects.
    """
    times = self.get_class('set_start_end_time').T.filter(regex='time')
    times = times.map(lambda x: pd.Timestamp(year=int(x[0]), month=int(x[1]), day=int(x[2])))

    start = times.start_time.min()
    end = times.end_time.max()
    times = pd.Series([start, end], index=['time_start', 'time_end'])

    return times</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.excel_config.check_strat_layer_values" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.excel_config.check_strat_layer_values(tuple_containing_dict)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Validate that stratigraphy layer parameters are physically plausible.</p>
<h4 id="cryogrid_pytools.excel_config.check_strat_layer_values--parameters">Parameters</h4>
<p>tuple_containing_dict : tuple
    A tuple containing a dictionary whose keys represent layer parameters.</p>
<h4 id="cryogrid_pytools.excel_config.check_strat_layer_values--raises">Raises</h4>
<p>ValueError
    If any parameter check fails for the stratigraphy layers.</p>
<h4 id="cryogrid_pytools.excel_config.check_strat_layer_values--notes">Notes</h4>
<h6 id="cryogrid_pytools.excel_config.check_strat_layer_values--definitions">Definitions</h6>
<ul>
<li><code>porosity = 1 - mineral - organic</code></li>
<li><code>airspace = porosity - waterIce</code></li>
<li><code>volume = mineral + organic + waterIce</code></li>
</ul>
<h6 id="cryogrid_pytools.excel_config.check_strat_layer_values--checks">Checks</h6>
<ul>
<li><code>field_capacity &lt; porosity</code>  :  field capacity is a subset of the porosity</li>
<li><code>airspace &gt;= 0</code>  :  cannot have negative airspace</li>
<li><code>volume &lt;= 1</code>  :  the sum of mineral, organic, and waterIce cannot exceed 1</li>
<li><code>waterIce &lt;= porosity</code>  :  waterIce cannot exceed porosity</li>
</ul>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/excel_config.py</code></summary>
              <pre class="highlight"><code class="language-python">def check_strat_layer_values(tuple_containing_dict):
    """
    Validate that stratigraphy layer parameters are physically plausible.

    Parameters
    ----------
    tuple_containing_dict : tuple
        A tuple containing a dictionary whose keys represent layer parameters.

    Raises
    ------
    ValueError
        If any parameter check fails for the stratigraphy layers.

    Notes
    -----
    #### Definitions
    - `porosity = 1 - mineral - organic`
    - `airspace = porosity - waterIce`
    - `volume = mineral + organic + waterIce`

    #### Checks
    - `field_capacity &lt; porosity`  :  field capacity is a subset of the porosity
    - `airspace &gt;= 0`  :  cannot have negative airspace
    - `volume &lt;= 1`  :  the sum of mineral, organic, and waterIce cannot exceed 1
    - `waterIce &lt;= porosity`  :  waterIce cannot exceed porosity

    """
    dictionary = tuple_containing_dict[0]
    df = pd.DataFrame(dictionary).astype(float).round(3)

    df['porosity'] = (1 - df.mineral - df.organic).round(3)
    df['airspace'] = (df.porosity - df.waterIce).round(3)
    df['volume'] = (df.mineral + df.organic + df.waterIce).round(3)

    checks = pd.DataFrame()
    checks['field_capacity_lt_porosity'] = df.field_capacity &lt;= df.porosity
    checks['airspace_ge_0'] = df.airspace &gt;= 0
    checks['volume_le_1'] = df.volume &lt;= 1
    checks['waterice_le_porosity'] = df.waterIce &lt;= df.porosity
    checks.index.name = 'layer'

    if not checks.values.all():
        raise ValueError(
            "parameters are not physically plausible. "
            "below are the violations: \n"
            + str(checks.T))</code></pre>
            </details>
    </div>

</div><h2 id="data-module-functions">Data Module Functions</h2>


<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.data.get_dem_copernicus30" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.data.get_dem_copernicus30(bbox_WSEN, res_m=30, epsg=32643, smoothing_iters=2, smoothing_size=3)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Download DEM data from the STAC catalog (default is COP DEM Global 30m).</p>
<h4 id="cryogrid_pytools.data.get_dem_copernicus30--parameters">Parameters</h4>
<p>bbox_WSEN : list
    The bounding box of the area of interest in WSEN format.
res_m : int
    The resolution of the DEM data in meters.
epsg : int, optional
    The EPSG code of the projection of the DEM data. Default is 
    EPSG:32643 (UTM 43N) for the Pamir region. 
smoothing_iters : int, optional
    The number of iterations to apply the smoothing filter. Default is 2.
    Set to 0 to disable smoothing.
smoothing_size : int, optional
    The size of the kernel (num pixels) for the smoothing filter. Default is 3.</p>
<h4 id="cryogrid_pytools.data.get_dem_copernicus30--returns">Returns</h4>
<p>xarray.DataArray
    The DEM data as an xarray DataArray with attributes.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/data.py</code></summary>
              <pre class="highlight"><code class="language-python">@_decorator_dataarray_to_bbox
def get_dem_copernicus30(bbox_WSEN:list, res_m:int=30, epsg=32643, smoothing_iters=2, smoothing_size=3)-&gt;_xr.DataArray:
    """
    Download DEM data from the STAC catalog (default is COP DEM Global 30m).

    Parameters
    ----------
    bbox_WSEN : list
        The bounding box of the area of interest in WSEN format.
    res_m : int
        The resolution of the DEM data in meters.
    epsg : int, optional
        The EPSG code of the projection of the DEM data. Default is 
        EPSG:32643 (UTM 43N) for the Pamir region. 
    smoothing_iters : int, optional
        The number of iterations to apply the smoothing filter. Default is 2.
        Set to 0 to disable smoothing.
    smoothing_size : int, optional
        The size of the kernel (num pixels) for the smoothing filter. Default is 3.

    Returns
    -------
    xarray.DataArray
        The DEM data as an xarray DataArray with attributes.
    """
    from .utils import drop_coords_without_dim

    check_epsg(epsg)

    assert res_m &gt;= 30, "The resolution must be greater than 30m for the COP DEM Global 30m dataset."
    res = res_m / 111111 if epsg == 4326 else res_m

    _logger.info("Fetching COP DEM Global 30m data from Planetary Computer")
    items = search_stac_items_planetary_computer('cop-dem-glo-30', bbox_WSEN)
    da_dem = _stackstac.stack(
        items=items, 
        bounds_latlon=bbox_WSEN,
        resolution=res,
        epsg=epsg)

    da_dem = (
        da_dem
        .mean('time')
        .squeeze()
        .pipe(drop_coords_without_dim)
        .pipe(smooth_data, n_iters=smoothing_iters, kernel_size=smoothing_size)
        .rio.write_crs(f"EPSG:{epsg}")
        .assign_attrs(
            source=items[0].links[0].href,  # collection URL
            bbox_request=bbox_WSEN))

    return da_dem</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.data.get_esa_land_cover" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.data.get_esa_land_cover(bbox_WSEN, res_m=30, epsg=32643)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Get the ESA World Cover dataset on the target grid and resolution.</p>
<h4 id="cryogrid_pytools.data.get_esa_land_cover--parameters">Parameters</h4>
<p>bbox_WSEN : tuple
    Bounding box in the format (West, South, East, North).
res_m : int, optional
    Resolution in meters. Defaults to 30.
epsg : int, optional
    EPSG code for the coordinate reference system. Defaults to 32643.</p>
<h4 id="cryogrid_pytools.data.get_esa_land_cover--returns">Returns</h4>
<p>xr.DataArray
    A DataArray with the land cover data on the target grid. Contains
    attributes 'class_values', 'class_descriptions', 'class_colors' for plotting.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/data.py</code></summary>
              <pre class="highlight"><code class="language-python">@_decorator_dataarray_to_bbox
def get_esa_land_cover(bbox_WSEN:tuple, res_m:int=30, epsg=32643)-&gt;_xr.DataArray:
    """
    Get the ESA World Cover dataset on the target grid and resolution.

    Parameters
    ----------
    bbox_WSEN : tuple
        Bounding box in the format (West, South, East, North).
    res_m : int, optional
        Resolution in meters. Defaults to 30.
    epsg : int, optional
        EPSG code for the coordinate reference system. Defaults to 32643.

    Returns
    -------
    xr.DataArray
        A DataArray with the land cover data on the target grid. Contains
        attributes 'class_values', 'class_descriptions', 'class_colors' for plotting.
    """

    def get_land_cover_classes(item):
        """ 
        Get the land cover class names, and colors from the ESA World Cover dataset

        Args:
            item (pystac.Item): The STAC item containing the land cover data.

        Returns:
            dict: A dictionary with class values, descriptions, and colors.
        """
        import pandas as pd

        classes = item.assets['map'].extra_fields['classification:classes']
        df = (
            pd.DataFrame(classes)
            .set_index('value')
            .rename(columns=lambda s: s.replace('-', '_'))  # bug fix for version 2.7.8 (stacstack back compatibility)
        )

        df['color_hint'] = '#' + df['color_hint']

        out = dict(
            class_values = df.index.values,
            class_descriptions = df['description'].values,
            class_colors = df['color_hint'].values)

        return out

    # make sure epsg is supported
    check_epsg(epsg)

    # get the units in the projection
    res = get_res_in_proj_units(res_m, epsg, min_res=10)

    _logger.info("Fetching ESA World Cover (v2.0) data from Planetary Computer")
    items = search_stac_items_planetary_computer(
        collection='esa-worldcover', 
        bbox=bbox_WSEN, 
        query={'esa_worldcover:product_version': {'eq': '2.0.0'}})

    stac_props = dict(
        items=items, 
        assets=['map'],
        epsg=epsg,
        bounds_latlon=bbox_WSEN,
        resolution=res)

    da = (
        _stackstac.stack(**stac_props)
        .max(['band', 'time'], keep_attrs=True)  # removing the single band dimension
        .rename('land_cover')
        .assign_attrs(**get_land_cover_classes(items[0]))
    )

    return da</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.data.get_snow_melt_doy" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.data.get_snow_melt_doy(bbox_WSEN, years=range(2018, 2025), res_m=30, epsg=32643)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Calculate the snow melt day of year (DOY) from Sentinel-2 SCL data for a given bounding box and years.</p>
<h4 id="cryogrid_pytools.data.get_snow_melt_doy--parameters">Parameters</h4>
<p>bbox_WSEN : tuple
    Bounding box coordinates in the format (West, South, East, North).
years : range, optional
    Range of years to consider. Defaults to range(2018, 2025).
res_m : int, optional
    Spatial resolution in meters. Defaults to 30.
epsg : int, optional
    EPSG code for the coordinate reference system. Defaults to 32643.</p>
<h4 id="cryogrid_pytools.data.get_snow_melt_doy--returns">Returns</h4>
<p>_xr.DataArray
    DataArray containing the snow melt DOY for each year.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/data.py</code></summary>
              <pre class="highlight"><code class="language-python">@_decorator_dataarray_to_bbox
def get_snow_melt_doy(bbox_WSEN:tuple, years=range(2018, 2025), res_m:int=30, epsg=32643)-&gt;_xr.DataArray:
    """
    Calculate the snow melt day of year (DOY) from Sentinel-2 SCL data for a given bounding box and years.

    Parameters
    ----------
    bbox_WSEN : tuple
        Bounding box coordinates in the format (West, South, East, North).
    years : range, optional
        Range of years to consider. Defaults to range(2018, 2025).
    res_m : int, optional
        Spatial resolution in meters. Defaults to 30.
    epsg : int, optional
        EPSG code for the coordinate reference system. Defaults to 32643.

    Returns
    -------
    _xr.DataArray
        DataArray containing the snow melt DOY for each year.
    """

    da = get_sentinel2_data(bbox_WSEN, years=years, res_m=res_m, epsg=epsg, max_cloud_cover=10)

    _logger.info("Calculating snow melt day of year (DOY) from Sentinel-2 SCL data")
    doy = da.groupby('time.year').apply(calc_sentinel2_snow_melt_doy)

    return doy</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cryogrid_pytools.data.get_randolph_glacier_inventory" class="doc doc-heading">
            <code class="highlight language-python">cryogrid_pytools.data.get_randolph_glacier_inventory(target_dem=None, dest_dir=None)</code>

</h2>


    <div class="doc doc-contents first">

        <p>Fetches the Randolph Glacier Inventory (RGI) data and returns it as a GeoDataFrame or raster dataset.</p>
<h4 id="cryogrid_pytools.data.get_randolph_glacier_inventory--parameters">Parameters</h4>
<p>target_dem : optional
    A digital elevation model (DEM) object. If provided, the function will return 
    the RGI data clipped to the bounding box of the DEM and reprojected to the DEM's CRS.
dest_dir : str, optional
    The directory where the downloaded RGI data will be stored. If None, the data will
    be stored in the pooch cache directory (~/.cache/pooch/).</p>
<h4 id="cryogrid_pytools.data.get_randolph_glacier_inventory--returns">Returns</h4>
<p>GeoDataFrame or raster dataset
    If target_dem is None, returns a GeoDataFrame containing the RGI data.
    If target_dem is provided, returns a raster dataset clipped and reprojected to the DEM.</p>


            <details class="quote">
              <summary>Source code in <code>cryogrid_pytools/data.py</code></summary>
              <pre class="highlight"><code class="language-python">@_cached
def get_randolph_glacier_inventory(target_dem=None, dest_dir=None):
    """
    Fetches the Randolph Glacier Inventory (RGI) data and returns it as a GeoDataFrame or raster dataset.

    Parameters
    ----------
    target_dem : optional
        A digital elevation model (DEM) object. If provided, the function will return 
        the RGI data clipped to the bounding box of the DEM and reprojected to the DEM's CRS.
    dest_dir : str, optional
        The directory where the downloaded RGI data will be stored. If None, the data will
        be stored in the pooch cache directory (~/.cache/pooch/).

    Returns
    -------
    GeoDataFrame or raster dataset
        If target_dem is None, returns a GeoDataFrame containing the RGI data.
        If target_dem is provided, returns a raster dataset clipped and reprojected to the DEM.
    """

    url = 'https://daacdata.apps.nsidc.org/pub/DATASETS/nsidc0770_rgi_v7/regional_files/RGI2000-v7.0-G/RGI2000-v7.0-G-13_central_asia.zip'

    downloader = _pooch.HTTPDownloader(progressbar=True, headers=get_earthaccess_session().headers)
    flist = download_url(url, path=dest_dir, downloader=downloader)

    fname_shp = [f for f in flist if f.endswith('.shp')][0]

    _logger.log("INFO", f"RGI: Fetching Randolph Glacier Inventory - see https://www.glims.org/rgi_user_guide/welcome.html")
    _logger.log("DEBUG", f"RGI: URL = {url}")
    _logger.log("DEBUG", f"RGI: FILE = {fname_shp}")

    if target_dem is None:
        # reads the whole file
        df = _gpd.read_file(fname_shp)
    else:
        # gets the bounding box and then reads the file
        bbox = target_dem.rv.get_bbox_latlon()
        df = _gpd.read_file(fname_shp, bbox=bbox).to_crs(target_dem.rio.crs)
        df = df.dissolve()
        ds = df.rv.to_raster(target_dem)
        return ds

    return df</code></pre>
            </details>
    </div>

</div><h2 id="utility-functions">Utility Functions</h2>
<p>Additional utility functions are available in the package. See the source code documentation for more details.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../usage/spatial-data/" class="btn btn-neutral float-left" title="Spatial Data and Forcing"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/lukegre/CryoGrid-pyTools" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../usage/spatial-data/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
