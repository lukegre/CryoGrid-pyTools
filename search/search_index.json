{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CryoGrid-pyTools","text":"<p>CryoGrid-pyTools is a Python package designed to facilitate working with CryoGrid MATLAB data in Python. It provides tools for reading and processing various types of data including:</p> <ul> <li>CryoGrid output (from <code>OUT_regridded_FCI2</code>)</li> <li>Simple MATLAB struct files</li> <li>ERA5 forcing data</li> <li>Excel run configuration files</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Easy-to-use interface for reading CryoGrid output files</li> <li>Support for both single and multiple file reading</li> <li>Conversion of MATLAB data structures to Python</li> <li>Integration with common data science libraries like xarray</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Getting Started</li> <li>API Reference</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page contains the detailed API reference for CryoGrid-pyTools.</p>"},{"location":"api-reference/#excel-config-file","title":"Excel Config file","text":""},{"location":"api-reference/#cryogrid_pytools.CryoGridConfigExcel","title":"<code>cryogrid_pytools.CryoGridConfigExcel</code>","text":"<p>A class to read CryoGrid Excel configuration files and extract file paths and maybe in the future do some checks etc</p>"},{"location":"api-reference/#cryogrid_pytools.CryoGridConfigExcel.get_class","title":"<code>get_class</code>","text":"<p>Return DataFrame blocks representing the specified class from the Excel data.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>The class name to look up (e.g., 'DEM', 'READ_DATASET').</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The concatenated DataFrame of class blocks.</p>"},{"location":"api-reference/#cryogrid_pytools.CryoGridConfigExcel.get_classes","title":"<code>get_classes</code>","text":"<p>Useful to find all the classes available in the Excel file. Returns a dictionary of class names and their corresponding row indices from the Excel file. To use as a reference for get_class(). <p>Returns:</p> Type Description <code>dict of int: str</code> <p>A dictionary mapping class names to row indices</p>"},{"location":"api-reference/#cryogrid_pytools.CryoGridConfigExcel.get_coord_path","title":"<code>get_coord_path</code>","text":"<p>Get the path to the coordinates file from the Excel configuration.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The file path for coordinates.</p>"},{"location":"api-reference/#cryogrid_pytools.CryoGridConfigExcel.get_dem_path","title":"<code>get_dem_path</code>","text":"<p>Get the path for the DEM file from the Excel configuration.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The DEM file path.</p>"},{"location":"api-reference/#cryogrid_pytools.CryoGridConfigExcel.get_output_max_depth","title":"<code>get_output_max_depth</code>","text":"<p>Get the maximum depth of the output file from the Excel configuration.</p> <p>Parameters:</p> Name Type Description Default <code>output_class</code> <code>str</code> <p>The class name to search for in the configuration, by default 'OUT_regridded'.</p> <code>'OUT_regridded'</code> <p>Returns:</p> Type Description <code>float</code> <p>The maximum depth value.</p>"},{"location":"api-reference/#reading-profile-outputs","title":"Reading profile outputs","text":""},{"location":"api-reference/#cryogrid_pytools.read_OUT_regridded_file","title":"<code>cryogrid_pytools.read_OUT_regridded_file</code>","text":"<p>Read a CryoGrid OUT_regridded[_FCI2] file and return it as an xarray dataset.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to the .mat file</p> required <code>deepest_point</code> <code>float</code> <p>Represents the deepest depth of the profile relative to the surfface. If not provided, then elevation is returned. Negative values represent depths below the surface.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ds</code> <code>Dataset</code> <p>Dataset with dimensions 'time' and 'level'. The <code>elevation</code> coordinate represents the elevation above sea level based on the DEM. If deepest_point is provided, then an additional coordinate, <code>depth</code>, represents depth above surface.</p> Notes <pre><code>For plotting, use `ds['variable'].plot(y='depth'/'elevation').\n</code></pre>"},{"location":"api-reference/#cryogrid_pytools.read_OUT_regridded_files","title":"<code>cryogrid_pytools.read_OUT_regridded_files</code>","text":"<p>Reads multiple files that are put out by the OUT_regridded class (and _FCI2)</p> <p>Parameters:</p> Name Type Description Default <code>fname_glob</code> <code>str</code> <p>Path of the files that you want to read in. Use same notation as for glob(). Note that it expects name to follow the format <code>some_project_name_GRIDCELL_ID_date.mat</code> where GRIDCELL_ID will be extracted to assign the gridcell dimension. These GRIDCELL_IDs correspond with the index of the data in the flattened array.</p> required <code>deepest_point</code> <code>Union[float, None]</code> <p>The depth below the surface that each profile is saved. If None, then depth is not returned as a coordinate.</p> <code>None</code> <code>joblib_kwargs</code> <p>Uses the joblib library to do parallel reading of the files. Defaults are: n_jobs=-1, backend='threading', verbose=1</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>An array with dimensions gridcell, depth, time. Variables depend on how the class was configured, but elevation will also be a variable.</p>"},{"location":"api-reference/#cryogrid_pytools.read_mat_struct_flat_as_dict","title":"<code>cryogrid_pytools.read_mat_struct_flat_as_dict</code>","text":"<p>Read a MATLAB struct from a .mat file and return it as a dictionary.</p> <p>Assumes that the struct is flat, i.e. it does not contain any nested structs.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to the .mat file</p> required <code>key</code> <code>str</code> <p>The name of the matlab key in the .mat file. If None is passed [default], then the first key that does not start with an underscore is used. If a string is passed, then the corresponding key is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>data</code> <code>dict</code> <p>Dictionary with the struct fields as keys and the corresponding data as values.</p>"},{"location":"api-reference/#cryogrid_pytools.read_mat_struct_as_dataset","title":"<code>cryogrid_pytools.read_mat_struct_as_dataset</code>","text":"<p>Read a MATLAB struct from a .mat file and return it as an xarray dataset.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to the .mat file. All variables in the struct are assumed to have the same dimensions and shape (except for the index columns).</p> required <code>drop_keys</code> <code>list</code> <p>List of keys to drop from the struct. If None is passed [default], then no keys are dropped. This can be used when one of the struct fields is not the same shape as the others. Any dropped variables will be added back as DataArrays with their own dim.</p> <code>[]</code> <code>index</code> <code>(str, tuple)</code> <p>Name of the index column. If None is passed [default], then no index is set. If a tuple is passed, then the corresponding columns are used as a multiindex.</p> <code>None</code> <code>index_is_datenum</code> <code>bool</code> <p>If True, then the index is converted from MATLAB datenum to a pandas.Timestamp.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ds</code> <code>Dataset</code> <p>Dataset with the struct fields as variables and the corresponding data as values.</p>"},{"location":"api-reference/#reading-clustering-outputs","title":"Reading clustering outputs","text":""},{"location":"api-reference/#cryogrid_pytools.spatial_clusters.read_spatial_data","title":"<code>cryogrid_pytools.spatial_clusters.read_spatial_data</code>","text":"<p>Opens run_spatial_info.mat that contains the spatial information for the run.</p> Note <p>You have to manually save this data since Python cannot read in the run_parameters.mat file. It needs to be a flat struct. Below is the MATLAB code to save the spatial data:</p> <pre><code>skip_fields = {'key'};\nfor field = fieldnames(run_info.SPATIAL.STATVAR)'\n    field_item_spatial = field{1}; % Extract string\n    if ~ismember(field_item_spatial, skip_fields)\n        data.(field_item_spatial) = run_info.SPATIAL.STATVAR.(field_item_spatial);\n    end\nend\n\nfor field = fieldnames(run_info.CLUSTER.STATVAR)'\n    field_item_cluster = field{1}; % Same fix here\n    data.(field_item_cluster) = run_info.CLUSTER.STATVAR.(field_item_cluster);\nend\n\nsname = strcat(provider.PARA.result_path, provider.PARA.run_name, '/run_spatial_info.mat');\nsave(sname, 'data');\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fname_spatial_mat</code> <code>str</code> <p>Path to the run_spatial_info.mat file</p> required <code>crs</code> <code>str</code> <p>Coordinate reference system of the spatial data (e.g., EPSG:32633) Get this from the DEM used in your run. If None, no CRS is added, by default None</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ds</code> <code>Dataset</code> <p>Dataset with the spatial information. Contains the variables: 1D variables [cluster_num as dim]:     - cluster_centroid_index:             the index of the cluster centroid of             each cluster with the cluster_num as the dimension 2D variables [y, x as dims]:     - longitude / latitude     - mask: mask of the indexs     - all variables in run_info.SPATIAL.STATVAR     - from run_info.CLUSTER.STATVAR         - cluster_number: the cluster number that each index belongs to         - cluster_number_mapped: a 2d representation of the cluster_number         - cluster_centroid_index: the index of the cluster centroid with cluster_number as the dim         - cluster_centroid_index_mapped: the index of the cluster centroid of each cluster</p>"},{"location":"api-reference/#cryogrid_pytools.spatial_clusters.map_gridcells_to_clusters","title":"<code>cryogrid_pytools.spatial_clusters.map_gridcells_to_clusters</code>","text":"<p>Maps the single depth selection of the profiles to the 2D clusters</p> <p>Parameters:</p> Name Type Description Default <code>da</code> <code>DataArray</code> <p>Single depth selection of the profiles with <code>index</code> dimension only. Note that <code>index</code> must start at 1 (0 is reserved for masked data).</p> required <code>cluster_centroid_index_mapped</code> <code>DataArray</code> <p>2D array with the index of the cluster centroid of each cluster Must have dtype uint32. Can have 0 to represent masked data.</p> required <p>Returns:</p> Name Type Description <code>da_2d_mapped</code> <code>DataArray</code> <p>The 2D array of the profiles mapped to the clusters with the same shape as cluster_centroid_index_mapped. The 2D gridcells will also be given as a coordinate</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If da (variable to be mapped) does not have index dimension only</p>"},{"location":"api-reference/#era5-forcing","title":"ERA5 Forcing","text":""},{"location":"api-reference/#cryogrid_pytools.forcing.read_mat_ear5","title":"<code>cryogrid_pytools.forcing.read_mat_ear5</code>","text":"<p>Read the ERA5.mat forcing file for CryoGrid and return a xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the ERA5.mat file</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with the variables from the ERA5.mat file</p>"},{"location":"api-reference/#cryogrid_pytools.forcing.era5_to_matlab","title":"<code>cryogrid_pytools.forcing.era5_to_matlab</code>","text":"<p>Convert a merged netCDF file from the Copernicus CDS to a dictionary that matches the expected format of the CryoGrid.POST_PROC.read_mat_ERA class (in MATLAB).</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset from the ERA5 Copernicus CDS with variables required for the CryoGrid.POST_PROC.read_mat_ERA class single_levels   = [u10, v10, sp, d2m, t2m, ssrd, strd, tisr, tp, Zs] pressure_levels = [t, z, q, u, v] Note that Zs in the single levels is a special case since it is only downloaded for a single date at the surface (doesn't change over time)</p> required <code>save_path</code> <code>str</code> <p>Path to save the dictionary as a .mat file, by default None, meaning no file is saved and only the dictionary is returned</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the variables mapped to names that are expected by CryoGrid.POST_PROC.read_mat_ERA</p>"},{"location":"api-reference/#elevation-land-cover-snow-melt","title":"Elevation, land cover, snow melt","text":""},{"location":"api-reference/#cryogrid_pytools.data.get_dem_copernicus30","title":"<code>cryogrid_pytools.data.get_dem_copernicus30</code>","text":"<p>Download DEM data from the STAC catalog (default is COP DEM Global 30m).</p> <p>Parameters:</p> Name Type Description Default <code>bbox_WSEN</code> <code>list</code> <p>The bounding box of the area of interest in WSEN format.</p> required <code>res</code> <code>int</code> <p>The resolution of the DEM data in EPSG units.</p> <code>30</code> <code>epsg</code> <code>int</code> <p>The EPSG code of the projection of the DEM data. Default is EPSG:32643 (UTM 43N) for the Pamir region.</p> <code>32643</code> <code>smoothing_iters</code> <code>int</code> <p>The number of iterations to apply the smoothing filter. Default is 2. Set to 0 to disable smoothing.</p> <code>2</code> <code>smoothing_size</code> <code>int</code> <p>The size of the kernel (num pixels) for the smoothing filter. Default is 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>The DEM data as an xarray DataArray with attributes.</p>"},{"location":"api-reference/#cryogrid_pytools.data.get_esa_land_cover","title":"<code>cryogrid_pytools.data.get_esa_land_cover</code>","text":"<p>Get the ESA World Cover dataset on the target grid and resolution.</p> <p>Parameters:</p> Name Type Description Default <code>bbox_WSEN</code> <code>tuple</code> <p>Bounding box in the format (West, South, East, North).</p> required <code>res</code> <code>int</code> <p>Resolution in EPSG units. Defaults to 30 (meters for UTM).</p> <code>30</code> <code>epsg</code> <code>int</code> <p>EPSG code for the coordinate reference system. Defaults to 32643.</p> <code>32643</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>A DataArray with the land cover data on the target grid. Contains attributes 'class_values', 'class_descriptions', 'class_colors' for plotting.</p>"},{"location":"api-reference/#cryogrid_pytools.data.get_snow_melt_doy","title":"<code>cryogrid_pytools.data.get_snow_melt_doy</code>","text":"<p>Calculate the snow melt day of year (DOY) from Sentinel-2 SCL data for a given bounding box and years.</p> <p>Parameters:</p> Name Type Description Default <code>bbox_WSEN</code> <code>tuple</code> <p>Bounding box coordinates in the format (West, South, East, North).</p> required <code>years</code> <code>range</code> <p>Range of years to consider. Defaults to range(2018, 2025).</p> <code>range(2018, 2025)</code> <code>res</code> <code>int</code> <p>Spatial resolution in meters. Defaults to 30.</p> <code>30</code> <code>epsg</code> <code>int</code> <p>EPSG code for the coordinate reference system. Defaults to 32643.</p> <code>32643</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray containing the snow melt DOY for each year.</p>"},{"location":"api-reference/#cryogrid_pytools.data.get_randolph_glacier_inventory","title":"<code>cryogrid_pytools.data.get_randolph_glacier_inventory</code>","text":"<p>Fetches the Randolph Glacier Inventory (RGI) data and returns it as a GeoDataFrame or raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>target_dem</code> <code>optional</code> <p>A digital elevation model (DEM) object. If provided, the function will return the RGI data clipped to the bounding box of the DEM and reprojected to the DEM's CRS.</p> <code>None</code> <code>dest_dir</code> <code>str</code> <p>The directory where the downloaded RGI data will be stored. If None, the data will be stored in the pooch cache directory (~/.cache/pooch/).</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame or raster dataset</code> <p>If target_dem is None, returns a GeoDataFrame containing the RGI data. If target_dem is provided, returns a raster dataset clipped and reprojected to the DEM.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with CryoGrid-pyTools. The package provides various functions to work with CryoGrid data in Python.</p>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>First, import the package:</p> <pre><code>import cryogrid_pytools as cg\n</code></pre> <p>The package provides several main functionalities:</p> <ol> <li>Reading CryoGrid output files</li> <li>Processing MATLAB struct files</li> <li>Working with ERA5 forcing data</li> <li>Handling configuration files</li> </ol> <p>Check out the specific guides for each functionality:</p> <ul> <li>Reading CryoGrid Output</li> <li>Reading MATLAB Structs</li> </ul>"},{"location":"getting-started/#example-notebook","title":"Example Notebook","text":"<p>For comprehensive examples, check out the <code>demo.ipynb</code> notebook in the repository. It contains detailed examples of various use cases and functionalities.</p>"},{"location":"installation/","title":"Installation","text":"<p>CryoGrid-pyTools can be easily installed using pip:</p> <pre><code>pip install cryogrid_pytools\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>CryoGrid-pyTools has several optional dependency groups that can be installed based on your needs:</p>"},{"location":"installation/#documentation-dependencies","title":"Documentation Dependencies","text":"<p>To build the documentation locally, install with the <code>docs</code> extra:</p> <pre><code>pip install \"cryogrid_pytools[docs]\"\n</code></pre>"},{"location":"installation/#data-processing-dependencies","title":"Data Processing Dependencies","text":"<p>For additional data processing capabilities, install with the <code>data</code> extra:</p> <pre><code>pip install \"cryogrid_pytools[data]\"\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to the development of CryoGrid-pyTools, you can install from source:</p> <pre><code>git clone https://github.com/lukegre/CryoGrid-pyTools.git\ncd CryoGrid-pyTools\npip install -e \".[docs,data]\"  # install with all optional dependencies\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>CryoGrid-pyTools requires Python 3.9 or later. The main dependencies are:</p> <ul> <li>numpy &gt;= 2.0</li> <li>scipy &gt;= 1.13.1</li> <li>xarray &gt;= 2024</li> <li>pandas &gt;= 2</li> <li>dask[array,diagnostics] &gt;= 2024</li> </ul> <p>These dependencies will be automatically installed when you install the package using pip.</p>"},{"location":"usage/forcing-spatial/","title":"Spatial Data and Forcing","text":"<p>The <code>data</code> module provides tools for creating forcing data and spatial data for CryoGrid spatial cluster runs. This module requires additional dependencies which can be installed using:</p> <pre><code>pip install \"cryogrid_pytools[data]\"\n</code></pre>"},{"location":"usage/forcing-spatial/#digital-elevation-model-dem","title":"Digital Elevation Model (DEM)","text":"<p>You can download DEM data from the Copernicus 30m dataset:</p> <pre><code>import cryogrid_pytools as cg\n\n# Define your area of interest (West, South, East, North)\nbbox = [70.0, 35.0, 71.0, 36.0]  # Example for a region in the Pamirs\n\n# Get DEM data at 30m resolution\ndem = cg.data.get_dem_copernicus30(\n    bbox_WSEN=bbox,\n    res_m=30,\n    epsg=32643,  # UTM 43N (default for Pamir region)\n    smoothing_iters=2,  # Apply smoothing to reduce noise\n    smoothing_size=3    # Kernel size for smoothing\n)\n</code></pre>"},{"location":"usage/forcing-spatial/#land-cover-data","title":"Land Cover Data","text":"<p>Get ESA World Cover data for your region:</p> <pre><code>landcover = cg.data.get_esa_land_cover(\n    bbox_WSEN=bbox,\n    res_m=30,\n    epsg=32643\n)\n</code></pre> <p>The returned DataArray includes attributes for class values, descriptions, and colors that can be used for plotting.</p>"},{"location":"usage/forcing-spatial/#snow-melt-timing","title":"Snow Melt Timing","text":"<p>Calculate snow melt timing using Sentinel-2 data:</p> <pre><code># Get snow melt day of year for multiple years\nsnow_melt = cg.data.get_snow_melt_doy(\n    bbox_WSEN=bbox,\n    years=range(2018, 2025),  # Analysis period\n    res_m=30,\n    epsg=32643\n)\n</code></pre>"},{"location":"usage/forcing-spatial/#glacier-data","title":"Glacier Data","text":"<p>Get Randolph Glacier Inventory (RGI) data for your region:</p> <pre><code># Get glacier data as a raster matching your DEM\nglacier_data = cg.data.get_randolph_glacier_inventory(target_dem=dem)\n\n# Or get raw vector data\nglacier_vector = cg.data.get_randolph_glacier_inventory()\n</code></pre>"},{"location":"usage/forcing-spatial/#era5-forcing-data","title":"ERA5 Forcing Data","text":"<p>The module provides access to ERA5 climate forcing data through the <code>era5_downloader</code> package:</p> <pre><code>from cryogrid_pytools.data import make_era5_downloader\n\n# Create an ERA5 downloader instance\nera5 = make_era5_downloader()\n\n# Download ERA5 data for your region and time period\nforcing = era5.get_data(\n    bbox_WSEN=bbox,\n    start_date=\"2018-01-01\",\n    end_date=\"2024-12-31\"\n)\n</code></pre>"},{"location":"usage/forcing-spatial/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage/forcing-spatial/#smoothing-data","title":"Smoothing Data","text":"<p>You can smooth any spatial data using a rolling mean filter:</p> <pre><code>smoothed_dem = cg.data.smooth_data(\n    dem,\n    kernel_size=3,\n    n_iters=2\n)\n</code></pre>"},{"location":"usage/forcing-spatial/#working-with-sentinel-2-data","title":"Working with Sentinel-2 Data","text":"<p>Get raw Sentinel-2 data for custom analysis:</p> <pre><code>sentinel_data = cg.data.get_sentinel2_data(\n    bbox_WSEN=bbox,\n    years=range(2018, 2025),\n    assets=['SCL'],  # Scene Classification Layer\n    res_m=30,\n    epsg=32643,\n    max_cloud_cover=5  # Maximum cloud cover percentage\n)\n</code></pre>"},{"location":"usage/forcing-spatial/#notes","title":"Notes","text":"<ol> <li>All spatial functions support consistent coordinate reference systems through the <code>epsg</code> parameter</li> <li>Resolution can be specified in meters using the <code>res_m</code> parameter</li> <li>The module handles data downloads and caching automatically</li> <li>Most functions support both vector (GeoDataFrame) and raster (xarray.DataArray) outputs</li> <li>Functions are decorated to handle both bounding box inputs and existing DataArrays for reprojection</li> </ol>"},{"location":"usage/forcing/","title":"Working with Forcing Data","text":"<p>CryoGrid-pyTools provides functionality to work with ERA5 forcing data for CryoGrid simulations.</p>"},{"location":"usage/forcing/#reading-era5-data","title":"Reading ERA5 Data","text":"<p>You can read ERA5 forcing data from MATLAB files using the <code>read_mat_ear5</code> function:</p> <pre><code>import cryogrid_pytools as cg\n\n# Read ERA5 forcing data\nds = cg.read_mat_ear5('path/to/ERA5.mat')\n</code></pre> <p>The returned xarray Dataset contains all ERA5 forcing variables needed for CryoGrid simulations.</p>"},{"location":"usage/forcing/#converting-era5-data","title":"Converting ERA5 Data","text":"<p>If you have ERA5 data from the Copernicus Climate Data Store (CDS) in netCDF format, you can convert it to the format expected by CryoGrid using <code>era5_to_matlab</code>:</p> <pre><code>import cryogrid_pytools as cg\n\n# Convert ERA5 netCDF to MATLAB format\nds = cg.era5_to_matlab(\n    era5_dataset,  # xarray Dataset from ERA5 CDS\n    save_path='ERA5.mat'  # Optional: save to MATLAB file\n)\n</code></pre> <p>The function expects the following variables in the input dataset:</p>"},{"location":"usage/forcing/#single-level-variables","title":"Single Level Variables","text":"<ul> <li>u10, v10: 10m wind components</li> <li>sp: Surface pressure</li> <li>d2m: 2m dewpoint temperature</li> <li>t2m: 2m temperature</li> <li>ssrd: Surface solar radiation downwards</li> <li>strd: Surface thermal radiation downwards</li> <li>tisr: TOA incident solar radiation</li> <li>tp: Total precipitation</li> <li>Zs: Surface geopotential (static)</li> </ul>"},{"location":"usage/forcing/#pressure-level-variables","title":"Pressure Level Variables","text":"<ul> <li>t: Temperature</li> <li>z: Geopotential</li> <li>q: Specific humidity</li> <li>u, v: Wind components</li> </ul> <p>The output will be formatted to match the requirements of the <code>CryoGrid.POST_PROC.read_mat_ERA</code> class in MATLAB.</p>"},{"location":"usage/mapping-clustered-runs/","title":"Mapping profile metrics to spatial maps","text":"<p>The key goal here is to map a single value from each spatial run to a map. The key thing to remember is that our profiles represent the temperature at the cluster centroid locations. We would like to map these centroid data to the entire spatial coverage of the cluster. To do this we have to read in the spatial data that contains information about the locations of the cluster centroids. This information can be retrieved from the <code>run_parameters.mat</code> file in MATLAB using the script in the last section.</p>"},{"location":"usage/mapping-clustered-runs/#read-the-profile-data","title":"Read the profile data","text":"<p>Using the standard function to read the regridded profiles. The deepest point is set to -20m (taken from the Excel config file). <pre><code>import cryogrid_pytools as cg\n\n# using regex pattern - [0-9]+ is the run number, 197[5-9] is 1975-1979, [0-9]{4} = mmdd part of the date\nfname_profiles = '.../runs/abramov-small-3classes/outputs/abramov-small-3classes_[0-9]+_197[5-9][0-9]{4}.mat'\n\n# the outputs of ds_profiles have dimensions [gridcell, depth, time]\nds_profiles = cg.read_OUT_regridded_files(fname_profiles, deepest_point=-20)\n</code></pre></p>"},{"location":"usage/mapping-clustered-runs/#reduce-variable-to-one-value-per-profile","title":"Reduce variable to one value per profile","text":"<p>If we want to map the data spatially, we can only do this if we have one aggregated value per profile. For example, we can calculate the mean temperature profiles imported above (1975-1979) and then select the temperature at 2m depth.</p> <pre><code># calculate mean temperature profile for each gridcell [gridcell, depth]\ntemp_profile_mean = (\n    ds_profiles['T']  # select the temperature data\n    .assign_attrs(long_name='Temperature', units='\u00b0C')  # assign attributes to the data (for plotting)\n    .mean('time', keep_attrs=True))  # calculate the mean over time, keeping the attributes\n\ntemp_2m_mean = (\n    temp_profile_mean\n    .sel(depth=-2, method='nearest')  # select the temperature at 2m depth (or the nearest depth)\n    .drop_vars(['depth', 'elevation'])  # drop the depth and elevation coordinates\n    .compute())  # load the data into memory\n)\n</code></pre>"},{"location":"usage/mapping-clustered-runs/#mapping-with-spatial-data","title":"Mapping with spatial data","text":"<p>For this to work, you need to have completed this part. The <code>cg.spatial_clusters.read_spatial_data</code> function reads the spatial data from the file saved in MATLAB and does some neat things in the backend. It maps the cluster centroid gridcell numbers to the map, making it easier to map the data to the spatial grid.</p> <p><pre><code>fname_spatial = \".../runs/abramov-small-3classes/outputs/run_spatial_info.mat\"\n\nds_spatial = cg.spatial_clusters.read_spatial_data(fname_spatial)\n\n# Here, we map the temperature data to the spatial grid using the cluster centroid gridcell numbers\ntemp_2m_mapped = cg.spatial_clusters.map_gridcells_to_clusters(\n    temp_2m_mean,  # dims = [gridcell]\n    ds_spatial.cluster_centroid_gridcell_2d,  # dims = [y, x]\n)\n\n# plot the output\nimg = temp_2m_mapped.plot.imshow(robust=True, aspect=2, size=5)\nimg.axes.set_aspect('equal')\n</code></pre> </p>"},{"location":"usage/mapping-clustered-runs/#saving-spatial-data-from-matlab","title":"Saving spatial data from MATLAB","text":"<p>We need to save spatial data from <code>run_parameters.mat</code> to a file that Python can read. The <code>run_parameters.mat</code> is not readable by Python because it is a struct array that contains custom CryoGrid classes that Python does not understand. So, to do this one has to run the following code in MATLAB:</p> <pre><code>cluster_num = run_info.CLUSTER.STATVAR.cluster_number;\n\ndata.coord_x = run_info.SPATIAL.STATVAR.X;\ndata.coord_y = run_info.SPATIAL.STATVAR.Y;\ndata.lat = run_info.SPATIAL.STATVAR.latitude;\ndata.lon = run_info.SPATIAL.STATVAR.longitude;\n\ndata.mask = run_info.SPATIAL.STATVAR.mask;\n\ndata.elevation = run_info.SPATIAL.STATVAR.altitude;\ndata.slope_angle = run_info.SPATIAL.STATVAR.slope_angle;\ndata.aspect = run_info.SPATIAL.STATVAR.aspect;\ndata.skyview_factor = run_info.SPATIAL.STATVAR.skyview_factor;\ndata.stratigraphy_index = run_info.SPATIAL.STATVAR.stratigraphy_index;\ndata.matlab_index = [1 : size(data.elevation, 1)]';\n\ndata.cluster_num = run_info.CLUSTER.STATVAR.cluster_number;\ndata.cluster_idx = run_info.CLUSTER.STATVAR.sample_centroid_index;\n\nsname = strcat(provider.PARA.result_path, provider.PARA.run_name, '/run_spatial_info.mat');\nsave(sname, 'data');\n</code></pre> <p>If you are using <code>CryoGrid-run-manager</code> this is automatically done for you by default.</p>"},{"location":"usage/reading-matlab/","title":"Reading MATLAB Structs","text":"<p>CryoGrid-pyTools provides functionality to read MATLAB struct files into Python. Here's how to work with MATLAB data.</p>"},{"location":"usage/reading-matlab/#important-note","title":"Important Note","text":"<p>Warning</p> <p>The <code>run_info.mat</code> file cannot be read directly as it contains special classes not supported by <code>scipy.io.loadmat</code>. You'll need to save the required data in a different format from MATLAB.</p>"},{"location":"usage/reading-matlab/#preparing-matlab-data","title":"Preparing MATLAB Data","text":"<p>When working in MATLAB, ensure you:</p> <ol> <li>Add the <code>CryoGrid/source</code> directory to the MATLAB path before saving files</li> <li>Save data in a compatible format</li> </ol> <p>For example, to save parts of <code>run_info</code>, use this MATLAB code:</p> <pre><code>% Save specific variables from run_info\nsave('my_data.mat', 'variable1', 'variable2', '-v7.3')\n</code></pre>"},{"location":"usage/reading-matlab/#reading-matlab-files-in-python","title":"Reading MATLAB Files in Python","text":"<p>Once you have your MATLAB data in a compatible format:</p> <pre><code>import cryogrid_pytools as cg\n\n# Read the MATLAB file\ndata = cg.read_matlab_file('my_data.mat')\n</code></pre> <p>The data will be converted to appropriate Python data structures, making it easy to work with in your Python environment.</p>"},{"location":"usage/reading-output/","title":"Reading CryoGrid Output","text":"<p>CryoGrid-pyTools provides functionality to read CryoGrid output files into Python. Currently, it supports reading regridded FCI2 output files.</p>"},{"location":"usage/reading-output/#reading-fci2-output-files","title":"Reading FCI2 Output Files","text":"<p>Use the <code>read_OUT_regridded_FCI2_file</code> function to read a regridded FCI2 output file:</p> <pre><code>import cryogrid_pytools as cg\n\n# Read a single output file\nds = cg.read_OUT_regridded_FCI2_file(\n    'path/to/your/output_file.mat',\n    deepest_point=-5  # Set the deepest point in meters\n)\n</code></pre> <p>The function returns an xarray Dataset with the following variables: - <code>time</code>: Time coordinate (datetime64) - <code>depth</code>: Depth coordinate in meters - <code>T</code>: Temperature - <code>water</code>: Water content - <code>ice</code>: Ice content - <code>class_number</code>: Class number - <code>FCI</code>: Frozen/Thawed state - <code>elevation</code>: Surface elevation</p>"},{"location":"usage/reading-output/#reading-multiple-files","title":"Reading Multiple Files","text":"<p>For spatial runs with multiple output files, use <code>read_OUT_regridded_FCI2_clusters</code>:</p> <pre><code># Read multiple output files\nds = cg.read_OUT_regridded_FCI2_clusters(\n    'path/to/output/directory/*.mat',  # Glob pattern for output files\n    deepest_point=-5\n)\n</code></pre> <p>The resulting Dataset will have an additional <code>gridcell</code> dimension for the spatial component.</p>"},{"location":"usage/reading-output/#data-structure","title":"Data Structure","text":"<p>The output is an xarray Dataset with:</p> <ul> <li>Dimensions:</li> <li><code>time</code>: Timesteps in the simulation</li> <li><code>depth</code>: Vertical grid points</li> <li> <p><code>gridcell</code>: (Only for cluster runs) Spatial grid points</p> </li> <li> <p>Variables:</p> </li> <li>All variables are stored as dask arrays for efficient memory usage</li> <li>Temperature and other fields are stored with dimensions (time, depth) or (gridcell, depth, time)</li> </ul>"},{"location":"usage/reading-output/#working-with-the-data","title":"Working with the Data","text":"<p>Being an xarray Dataset, you can use all standard xarray operations:</p> <p>```python</p>"},{"location":"usage/reading-output/#select-a-specific-time","title":"Select a specific time","text":"<p>ds.sel(time='2000-01-01')</p>"},{"location":"usage/reading-output/#get-mean-temperature-over-time","title":"Get mean temperature over time","text":"<p>ds.T.mean(dim='time')</p>"},{"location":"usage/reading-output/#plot-temperature-profile","title":"Plot temperature profile","text":"<p>ds.T.plot()</p>"}]}